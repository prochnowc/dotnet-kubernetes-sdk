// <auto-generated>
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

#nullable enable

using Kubernetes.Models;
using Kubernetes.Client;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Kubernetes.Client.Operations;

{{ operationsTypeName = Model.Name | string.append "Operations" -}}

/// <summary>
/// Provides the operations for the {{ Model.Name }} endpoints.
/// </summary>
public sealed partial class {{ operationsTypeName }} : KubernetesClientOperations
{
    internal {{ operationsTypeName }}(KubernetesClient client)
        : base(client)
    {
    }

    {{~ for method in Model.Methods ~}}
    {{ method.Description | xml_doc "summary" ~}}
    {{~ for parameter in method.AllParameters ~}}
    {{ parameter.Description | xml_doc "param" $'name="{parameter.Name}"' ~}}
    {{~ end ~}}
    public async {{ method | dotnet_return_type_async }} {{ method.Name }}Async(
        {{ method | dotnet_format_parameters_async }})
    {
        var requestUri = new RequestUriBuilder("{{ method.Path }}")
        {{~ for parameter in method.AllParameters ~}}
            .AddPathParameter("{{ parameter.Name }}", {{ parameter.ParameterName }})
        {{~ end ~}}
        {{~ if (method.Name | string.starts_with "Watch") ~}}
            .AddQueryParameter("watch", true)
        {{~ end ~}}
            .ToUri();

        var request = new KubernetesRequest(
            HttpMethods.{{ method.Method}},
            {{~ if (array.size method.Consumes) > 0 ~}}
            new [] {
                {{~ for mediaType in method.Consumes ~}}
                "{{ mediaType }}"{{ if !for.last }},{{ end }}
                {{~ end ~}}
            },
            {{~ else ~}}
            new string[0],
            {{~ end ~}}
            {{~ if (array.size method.Produces) > 0 ~}}
            new [] {
                {{~ for mediaType in method.Produces ~}}
                "{{ mediaType }}"{{ if !for.last }},{{ end }}
                {{~ end ~}}
            },
            {{~ else ~}}
            new string[0],
            {{~ end ~}}
            requestUri);
        {{~ if method.Body != null ~}}

        request.Content = {{ method.Body.ParameterName }};
        {{~ end ~}}

        using var response = await Client.SendAsync(request, cancellationToken)
            .ConfigureAwait(false);

        {{ if (method.Name | string.starts_with "Watch") -}}
        return await response.ReadAsWatcherAsync<{{ method.ResultType }}>(cancellationToken)
            .ConfigureAwait(false);
        {{- else if method.ResultType == "Stream" -}}
        return await response.ReadAsStreamAsync(cancellationToken)
            .ConfigureAwait(false);
        {{- else if method.ResultType != "void" -}}
        return await response.ReadAsContentAsync<{{ method.ResultType }}>(cancellationToken)
            .ConfigureAwait(false);
        {{- end }}
    }
    {{~ if !for.last ~}}

    {{~ end ~}}
    {{~ end ~}}
}
